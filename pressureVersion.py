# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ywNUW40BE6eRyfkF6ccLHbDR8B9wU-7_
"""

from google.colab import drive
drive.mount('/content/gdrive')

""".

"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.initializers import Constant
import matplotlib.pyplot as plt

# CSV 파일에서 데이터 로드
data = pd.read_csv("/content/gdrive/MyDrive/다니고밴.csv",encoding='utf-8')  # 파일 경로에 맞게 수정

data.head()

# 필요한 변수 선택
features = ['거리']  # 사용할 변수 선택 (온도만 사용)
target_variable = '연료 사용량 (km)'  # 예측할 변수 선택

print(data.head())



# 필요한 변수 선택
features = ['거리']  # 사용할 변수 선택 (온도만 사용)
target_variable = '연료 사용량 (km)'  # 예측할 변수 선택

# 온도 및 배터리 소모량 데이터만 추출 => 새로운 데이터 프레임 만들기
data = data[features + [target_variable]]

# 결측치 처리 (만약 있으면)
data = data.dropna()  # 결측치 제거



# 입력 변수와 출력 변수 분리
X = data[features].values  # (입력변수)features에 있는 열 선택 후 .values를 이용하여 numpy배열로 변환
y = data[target_variable].values  # (출력변수)

# 데이터 정규화
scaler = MinMaxScaler()  # Min-Max 스케일러를 사용하여 데이터를 [0, 1] 범위로 정규화
X_scaled = scaler.fit_transform(X)  # 1차원 배열을 열벡터 형태로 변환하여 정규화

# 학습 및 테스트 데이터로 분할
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)  # 데이터를 학습용과 테스트용으로 나눔
#(test_size : 데이터를 테스트세트로 사용할 비율)

# 데이터를 LSTM 입력 형태로 변환(데이터 전처리)
X_train = X_train.reshape((X_train.shape[0], 1, X_train.shape[1]))  # LSTM 입력 형태로 데이터 변환
#2차원인 X_train을 3차원배열로 바꿔줌
X_test = X_test.reshape((X_test.shape[0], 1, X_test.shape[1]))

#ex) 가중치 상수 설정
temperature_weight = 1.0

# LSTM 모델 생성
model = Sequential()  # Sequential 모델 생성
model.add(LSTM(units=50, activation='relu', input_shape=(X_train.shape[1], X_train.shape[2]), kernel_initializer=Constant(value=temperature_weight)))  # LSTM 레이어 추가
model.add(Dense(units=1))  # 출력 레이어 추가

# 모델 컴파일
model.compile(optimizer='adam', loss='mean_squared_error')

# 모델 학습
model.fit(X_train, y_train, epochs=70, batch_size=32, validation_data=(X_test, y_test))
#(50번 반복, 한번의 반복동안 32개만큼 사용됨)

# 모델 평가
loss = model.evaluate(X_test, y_test)  # 테스트 데이터로 모델을 평가하고 손실 값을 출력(손실값 작을수록 성능 좋음)
print(f'Mean Squared Error on Test Data: {loss}')

# 예측
y_pred = model.predict(X_test)  # 학습된 모델을 사용하여 테스트 데이터에 대한 예측 수행

import matplotlib.pyplot as plt

# 시각화
plt.figure(figsize=(12, 6))

# 실제 데이터와 모델 예측 결과 선 그래프로 표시
plt.plot(y_test, label='real data', marker='o')
plt.plot(y_pred, label='predicted', marker='o', linestyle='dashed', color='orange')

# 그래프 제목 및 레이블 설정
plt.title('실제 데이터와 모델 예측 결과')
plt.xlabel('데이터 포인트')
plt.ylabel('Battery Consumption')
plt.legend()

# 추세선 추가
plt.plot(np.arange(len(y_test)), np.poly1d(np.polyfit(np.arange(len(y_test)), y_test, 1))(np.arange(len(y_test))), label='실제 데이터 추세', linestyle='dashed', color='green')
plt.plot(np.arange(len(y_test)), np.poly1d(np.polyfit(np.arange(len(y_test)), y_pred.flatten(), 1))(np.arange(len(y_test))), label='모델 예측 추세', linestyle='dashed', color='red')

# 그래프 표시
plt.show()