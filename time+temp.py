# -*- coding: utf-8 -*-
"""Untitled6.ipynb의 사본의 사본

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WK3cGIvfRSjKrn7-niiViYeBzlSz_YIG
"""

from google.colab import drive
drive.mount('/content/gdrive')

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.initializers import Constant
import matplotlib.pyplot as plt

"""# 새 섹션"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.initializers import Constant
import matplotlib.pyplot as plt

danigoApp = pd.read_csv("/content/sample_data/다니고밴-[전주]Type12-역방향-20231117.csv", encoding = 'UTF-8')

danigoIot4 = pd.read_csv("/content/sample_data/다니고밴-[전주]Type12-역방향-20230312.csv", encoding = 'UTF-8')
danigoIot1 = pd.read_csv("/content/sample_data/다니고밴-[전주]Type12-역방향-20230309.csv", encoding = 'UTF-8')
danigoIot2 = pd.read_csv("/content/sample_data/다니고밴-[전주]Type12-역방향-20230310.csv", encoding = 'UTF-8')
danigoIot3 = pd.read_csv("/content/sample_data/다니고밴-[전주]Type12-역방향-20230311.csv", encoding = 'UTF-8')
danigoIot5 = pd.read_csv("/content/sample_data/다니고밴-[전주]Type12-역방향-20230313.csv", encoding = 'UTF-8')

danigoIotDatas = []
danigoIotDatas.append(danigoIot1)
danigoIotDatas.append(danigoIot2)
danigoIotDatas.append(danigoIot3)
danigoIotDatas.append(danigoIot4)
danigoIotDatas.append(danigoIot5)

#시작일 기준 행 추출하기
dataNow = 20230309
tempAvg = []
n = []
for date in range(5):
    temp = danigoApp[danigoApp['시작일'] == dataNow]

    temp['시작 시간'] = temp['시작 시간'].str.replace(':', '')
    temp['시작 시간'] = temp['시작 시간'].astype('int64')
    temp['시작 시간'] = temp['시작 시간'] * 100

    temp['종료시간'] = temp['종료시간'].str.replace(':', '')
    temp['종료시간'] = temp['종료시간'].astype('int64')
    temp['종료시간'] = (temp['종료시간'] * 100) + 59

    start = list(temp['시작 시간'])
    stop = list(temp['종료시간'])

    for i in range(len(start)):
        n.append(danigoIotDatas[date][(danigoIotDatas[date]['등록시간'] <= stop[i]) & (danigoIotDatas[date]['등록시간'] >= start[i])])

    dataNow += 1

#평균온도계산

def outlier_remove(data, threshold=3):
    z_scores = np.abs(data - np.mean(data)) / np.std(data) # Z-score 계산

    filtered_data = data[z_scores < threshold]
    outlier = data[z_scores>threshold]

    return filtered_data, outlier

outlierdata = []
filtered_datas = []

for i in range(len(n)):
    #filtered_data, outlier, q1, q3, IQR, lower_bound, upper_bound = outlier_remove(n[i]['온도(°C)'])
    filtered_data, outlier = outlier_remove(n[i]['온도(°C)'])
    outlierdata.append(outlier)
    filtered_datas.append(filtered_data)


print(danigoApp)
print(danigoIot1)


#데이터 길이 확인
#for i in range(len(outlierdata)):
#    print('잘린 거:', len(outlierdata[i]))
#    print('남은 거:', len(filtered_datas[i]))

"""외부온도를 진행해보겠다"""

import numpy as np
import pandas as pd

from matplotlib import pyplot as plt
from sklearn.linear_model import LinearRegression
pd.set_option('mode.chained_assignment',  None)

#우선 파일을 읽는다.
Weather=pd.read_csv("/content/gdrive/MyDrive/도로노선정보-20231114/전주 기온.csv",encoding='cp949')
Appdata=pd.read_csv("/content/gdrive/MyDrive/도로노선정보-20231114/다니고밴-[전주]Type12-역방향/APP/다니고밴-[전주]Type12-역방향-20231117.csv")
#필터링 함수

def outlier_remove(data, threshold=3):
    z_scores = np.abs(data - np.mean(data)) / np.std(data) # Z-score 계산

    filtered_data = data[z_scores < threshold]
    outlier = data[z_scores>threshold]

    return filtered_data, outlier

#외부온도 날씨 데이터 날짜 시간 분 구분해서 Dataframe에 넣는다

Weather[['날짜','시간']]=Weather['일시'].str.split(" ",expand=True)
Weather[['연','월','일']]= Weather['날짜'].str.split("-",expand=True)
#Weather[['시', '분']]=Weather['시간'].str.split(":",expand=True)
Weather['시간']=Weather['시간'].str.replace(":","")
print(list(Weather['시간']))
#print(Weather)
#앱데이터의 날짜를 불러온다
tempAvg = []
for date in range(20230309 , 20230313):
    temp = Appdata[Appdata['시작일'] == date]

    temp['시작 시간'] = temp['시작 시간'].str.replace(':', '')
    temp['시작 시간'] = temp['시작 시간'].astype(int)

    temp['종료시간'] = temp['종료시간'].str.replace(':', '')
    temp['종료시간'] = temp['종료시간'].astype(int)
    App_start = list(temp['시작 시간'])
    App_stop = list(temp['종료시간'])

    #시간 조건에 맞춰서 시간을 컷했다
    for i in range(len(App_stop)):
      line_fitter=LinearRegression()
      line_fitter.fit(Weather[Weather.loc[
          Weather['시간']==str(App_stop[i]),
                  ['기온(°C)']
      ]],temp['연료 사용량 (km)'])
    """
    for i in range(len(App_start)):
      line_fitter=LinearRegression()

      #해당 일자의 해당 시간을 불러왔으면 그 데이터로 센서 데이터를 불러온다
      line_fitter.fit(Weather.loc[
          ((Weather.시.astype(int)==int(App_stop[i]/100)) #시 조건
          & (Weather.분.astype(int)==int(App_stop[i]%100))) #분 조건
      ,['기온(°C)']],temp['연료 사용량 (km)'])"""

"""이 파트는 선형회귀 방식으로 푸는 방식이다 우선 시간 먼저 해보자

"""

import numpy as np
import pandas as pd

from matplotlib import pyplot as plt
from sklearn.linear_model import LinearRegression

#우선 파일을 읽는다.
Iot1=pd.read_csv("/content/gdrive/MyDrive/도로노선정보-20231114/다니고밴-[전주]Type12-역방향/LTE Device/다니고밴-[전주]Type12-역방향-20230309.csv")
iot2=pd.read_csv("/content/gdrive/MyDrive/도로노선정보-20231114/다니고밴-[전주]Type12-역방향/LTE Device/다니고밴-[전주]Type12-역방향-20230310.csv")
iot3=pd.read_csv("/content/gdrive/MyDrive/도로노선정보-20231114/다니고밴-[전주]Type12-역방향/LTE Device/다니고밴-[전주]Type12-역방향-20230311.csv")
iot4=pd.read_csv("/content/gdrive/MyDrive/도로노선정보-20231114/다니고밴-[전주]Type12-역방향/LTE Device/다니고밴-[전주]Type12-역방향-20230312.csv")
iot5=pd.read_csv("/content/gdrive/MyDrive/도로노선정보-20231114/다니고밴-[전주]Type12-역방향/LTE Device/다니고밴-[전주]Type12-역방향-20230313.csv")
Appdata=pd.read_csv("/content/gdrive/MyDrive/도로노선정보-20231114/다니고밴-[전주]Type12-역방향/APP/다니고밴-[전주]Type12-역방향-20231117.csv")
#필터링 함수
def outlier_remove(data, threshold=3):
    z_scores = np.abs(data - np.mean(data)) / np.std(data) # Z-score 계산

    filtered_data = data[z_scores < threshold]
    outlier = data[z_scores>threshold]

    return filtered_data, outlier

# 시간 ....필터링 해야됨...
X=np.array(Appdata['소요 시간(분)'].to_numpy())
filtered_X,outlierX=outlier_remove(X)
Y=np.array(Appdata['연료 사용량 (km)'].to_numpy())
filtered_Y,outlierY=outlier_remove(Y)

print(X)
print(Y)

# 데이터프레임에서 outlier 값을 뺴기 위해 실행
print(filtered_X)#필터된 값 확인
print(outlierX)#걸러진 값 확인
print(filtered_Y)
print(outlierY)

#이상값있는 데이터 시각화
timeline_fitter=LinearRegression() #선형회귀 함수 호출
timeline_fitter.fit(X.reshape(-1,1),Y.reshape(-1,1)) #예측
timeline_fitter.predict([[60]]) #example 60분을 달렸을 때 어느 정도의 값을 요구할 것인가
plt.plot(X, Y.reshape(-1,1), 'o') # 이하 시각화
plt.plot(X.reshape(-1,1),timeline_fitter.predict(X.reshape(-1,1)))
plt.show()

#이때 Threshold가 <=2가 되면 안되는데 그 이유는...뭐지...?

#Appdata.drop(Appdata[Appdata['소요 시간(분)']!=outlierX[i]])
#Appdata.drop(Appdata[Appdata['연료 사용량 (km)']!=outlierY[i]])

for i in outlierX:
  Appdata.drop(Appdata[Appdata['소요 시간(분)']!=outlierX[i]])

for i in outlierY:
  Appdata=(Appdata[Appdata['연료 사용량 (km)']!=outlierY[i]])

# 데이터 프레임에서 Filtered 값을 쓰기 위해 실행
X=np.array(Appdata['소요 시간(분)'].to_numpy())
filtered_X,outlierX=outlier_remove(X)
Y=np.array(Appdata['연료 사용량 (km)'].to_numpy())
filtered_Y,outlierY=outlier_remove(Y)

#이상값 없는 데이터 시각화
timeline_fitter=LinearRegression() #선형회귀 함수 호출
timeline_fitter.fit(filtered_X.reshape(-1,1),filtered_Y.reshape(-1,1)) #예측
print(timeline_fitter.predict([[60]])) #example 60분을 달렸을 때 어느 정도의 값을 요구할 것인가
plt.plot(filtered_X, filtered_Y.reshape(-1,1), 'o') # 이하 시각화
plt.plot(filtered_X.reshape(-1,1),timeline_fitter.predict(filtered_X.reshape(-1,1)))
plt.show()

#이 이하는 소요시간+휴게시간
X=np.array(Appdata['소요 시간(분)'].to_numpy())
filtered_X,outlierX=outlier_remove(X)
Y=np.array(Appdata['연료 사용량 (km)'].to_numpy())
filtered_Y,outlierY=outlier_remove(Y)
Z=np.array(Appdata['휴게 시간(분)'].to_numpy())
filtered_Z,outlierZ=outlier_remove(Z)

#이상값 없는 데이터 시각화
timeline_fitter=LinearRegression() #선형회귀 함수 호출
timeline_fitter.fit((filtered_X+filtered_Z).reshape(-1,1),filtered_Y.reshape(-1,1)) #예측
print(timeline_fitter.predict([[60]])) #example 60분을 달렸을 때 어느 정도의 값을 요구할 것인가
plt.plot((filtered_X+filtered_Z), filtered_Y.reshape(-1,1), 'o') # 이하 시각화
plt.plot((filtered_X+filtered_Z).reshape(-1,1),timeline_fitter.predict((filtered_X+filtered_Z).reshape(-1,1)))
plt.show()

# CSV 파일에서 데이터 로드
data = pd.read_csv("/content/sample_data/다니고밴-[전주]Type12-역방향-20231117.csv",encoding='utf-8')  # 파일 경로에 맞게 수정

data.head()

# 필요한 변수 선택
features = ['소요 시간(분)']  # 사용할 변수 선택 (온도만 사용)
target_variable = '연료 사용량 (km)'  # 예측할 변수 선택

print(data.head())

# 필요한 변수 선택
features = ['소요 시간(분)']  # 사용할 변수 선택 (온도만 사용)
target_variable = '연료 사용량 (km)'  # 예측할 변수 선택

# 온도 및 배터리 소모량 데이터만 추출 => 새로운 데이터 프레임 만들기
data = data[features + [target_variable]]

# 결측치 처리 (만약 있으면)
data = data.dropna()  # 결측치 제거

# 입력 변수와 출력 변수 분리
X = data[features].values  # (입력변수)features에 있는 열 선택 후 .values를 이용하여 numpy배열로 변환
y = data[target_variable].values  # (출력변수)

# 데이터 정규화
scaler = MinMaxScaler()  # Min-Max 스케일러를 사용하여 데이터를 [0, 1] 범위로 정규화
X_scaled = scaler.fit_transform(X)  # 1차원 배열을 열벡터 형태로 변환하여 정규화

# 학습 및 테스트 데이터로 분할
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)  # 데이터를 학습용과 테스트용으로 나눔
#(test_size : 데이터를 테스트세트로 사용할 비율)

# 데이터를 LSTM 입력 형태로 변환(데이터 전처리)
X_train = X_train.reshape((X_train.shape[0], 1, X_train.shape[1]))  # LSTM 입력 형태로 데이터 변환
#2차원인 X_train을 3차원배열로 바꿔줌
X_test = X_test.reshape((X_test.shape[0], 1, X_test.shape[1]))

#ex) 가중치 상수 설정
temperature_weight = 5.0

# LSTM 모델 생성
model = Sequential()  # Sequential 모델 생성
model.add(LSTM(units=50, activation='relu', input_shape=(X_train.shape[1], X_train.shape[2]), kernel_initializer=Constant(value=temperature_weight)))  # LSTM 레이어 추가
model.add(Dense(units=1))  # 출력 레이어 추가

# 모델 컴파일
model.compile(optimizer='adam', loss='mean_squared_error')

# 모델 학습
model.fit(X_train, y_train, epochs=70, batch_size=32, validation_data=(X_test, y_test))
#(50번 반복, 한번의 반복동안 32개만큼 사용됨)

# 모델 평가
loss = model.evaluate(X_test, y_test)  # 테스트 데이터로 모델을 평가하고 손실 값을 출력(손실값 작을수록 성능 좋음)
print(f'Mean Squared Error on Test Data: {loss}')

# 예측
y_pred = model.predict(X_test)  # 학습된 모델을 사용하여 테스트 데이터에 대한 예측 수행

plt.figure(figsize=(12, 6))

# 실제 데이터 (온도와 습도)
plt.plot(data.index[-len(y_test):], data['소요 시간(분)'][-len(y_test):], label='Actual Temperature', alpha=0.7, marker='o')
plt.plot(data.index[-len(y_test):], data['온도'][-len(y_test):], label='Actual Humidity', alpha=0.7, marker='o')

# 예측 결과 (두 변수를 고려한 예측)
plt.plot(data.index[-len(y_test):], y_pred, label='Predicted', color='orange', alpha=0.7, marker='o')
#plt.plot(y_pred, label='predicted', marker='o', linestyle='dashed', color='orange')

plt.title('Actual and Predicted Variables')
plt.xlabel('Data Point')
plt.ylabel('Values')
plt.legend()
plt.show()

import matplotlib.pyplot as plt

# 시각화
plt.figure(figsize=(12, 6))

# 실제 데이터와 모델 예측 결과 선 그래프로 표시
plt.plot(y_test, label='real data', marker='o')
plt.plot(y_pred, label='predicted', marker='o', linestyle='dashed', color='orange')

# 그래프 제목 및 레이블 설정
plt.title('실제 데이터와 모델 예측 결과')
plt.xlabel('데이터 포인트')
plt.ylabel('Battery Consumption')
plt.legend()

# 추세선 추가
plt.plot(np.arange(len(y_test)), np.poly1d(np.polyfit(np.arange(len(y_test)), y_test, 1))(np.arange(len(y_test))), label='실제 데이터 추세', linestyle='dashed', color='green')
plt.plot(np.arange(len(y_test)), np.poly1d(np.polyfit(np.arange(len(y_test)), y_pred.flatten(), 1))(np.arange(len(y_test))), label='모델 예측 추세', linestyle='dashed', color='red')

# 그래프 표시
plt.show()

"""여기서는 신호등 정보 가져오기"""

import request

def test():
    params = request.get_json()
    print("받은 Json 데이터 ", params)

    response = {
        "result": "ok"
    }

    return jsonify(response)

URL="http://apis.data.go.kr/6450000/trafficlights/gettrafficlights"

Params=request.get(URL,Key,)

Key="RCCgragG2f9o8bPk%2Fjy1fF0ECwIEjc%2BLI%2BYotqaj9Bq1FiUBnbIge%2ByK3m2ojSJrT8IwU9CZBrq8bnA655JMCg%3D%3D"